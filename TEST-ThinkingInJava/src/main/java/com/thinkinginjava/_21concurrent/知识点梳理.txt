1、Thread.yield();
    线程让步。当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。
    yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；
    但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！

    举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。
    然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。

    但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，
    最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。


2、Thread.start();
    多次start一个线程会怎么样？-----会抛出异常java.lang.IllegalThreadStateException( 线程状态非法异常 )
    多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。

    start和run的区别:
    调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。

    用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。
    通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，
    一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。

    run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，
    还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

    对比BasicThread和MainActivity.


3、线程


    线程状态从大的方面来说，可归结为：初始状态、可运行状态、不可运行状态和消亡状态，具体可细分为上图所示7个状态，说明如下：

    1）线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口，但不管怎样，当我们new了thread实例后，线程就进入了初始状态；
    2）当该对象调用了start()方法，就进入可运行状态；
    3）进入可运行状态后，当该对象被操作系统选中，获得CPU时间片就会进入运行状态；
    4）进入运行状态后case就比较多，大致有如下情形：
    run()方法或main()方法结束后，线程就进入终止状态；
    当线程调用了自身的sleep()方法或其他线程的join()方法，就会进入阻塞状态(该状态既停止当前线程，但并不释放所占有的资源)。
    当sleep()结束或join()结束后，该线程进入可运行状态，继续等待OS分配时间片；
    当线程刚进入可运行状态(注意，还没运行)，发现将要调用的资源被锁牢(synchroniza,lock)，将会立即进入锁池状态，等待获取锁标记
    (这时的锁池里也许已经有了其他线程在等待获取锁标记，这时它们处于队列状态，既先到先得)，
    一旦线程获得锁标记后，就转入可运行状态，等待OS分配 CPU时间片；
    当线程调用wait()方法后会进入等待队列(进入这个状态会释放所占有的所有资源，与阻塞状态不同)，
    进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒
    (由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，
    因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程)，线程被唤醒后会进入锁池，等待获取锁标记。
    当线程调用stop方法，即可使线程进入消亡状态，但是由于stop方法是不安全的，不鼓励使用，可以通过run方法里的条件变通实现线程的stop。
