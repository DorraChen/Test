1、Thread.yield();
    线程让步。当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。
    yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；
    但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！

    举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。
    然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。

    但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，
    最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。


2、Thread.start();
    多次start一个线程会怎么样？-----会抛出异常java.lang.IllegalThreadStateException( 线程状态非法异常 )
    多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。

    start和run的区别:
    调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。

    用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。
    通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，
    一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。

    run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，
    还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

    对比BasicThread和MainActivity.


3、线程

    线程状态从大的方面来说，可归结为：初始状态、可运行状态、不可运行状态和消亡状态，具体可细分为上图所示7个状态，说明如下：

    (1)线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口，但不管怎样，当我们new了thread实例后，线程就进入了初始状态；

    (2)当该对象调用了start()方法，就进入可运行状态；

    (3)进入可运行状态后，当该对象被操作系统选中，获得CPU时间片就会进入运行状态；

    (4)进入运行状态后case就比较多，大致有如下情形：
      run()方法或main()方法结束后，线程就进入终止状态；
      当线程调用了自身的sleep()方法或其他线程的join()方法，就会进入阻塞状态(该状态既停止当前线程，但并不释放所占有的资源)。
      当sleep()结束或join()结束后，该线程进入可运行状态，继续等待OS分配时间片；
      当线程刚进入可运行状态(注意，还没运行)，发现将要调用的资源被锁牢(synchroniza,lock)，将会立即进入锁池状态，等待获取锁标记
      (这时的锁池里也许已经有了其他线程在等待获取锁标记，这时它们处于队列状态，既先到先得)，
      一旦线程获得锁标记后，就转入可运行状态，等待OS分配 CPU时间片；
      当线程调用wait()方法后会进入等待队列(进入这个状态会释放所占有的所有资源，与阻塞状态不同)，
      进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒
      (由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，
      因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程)，线程被唤醒后会进入锁池，等待获取锁标记。
      当线程调用stop方法，即可使线程进入消亡状态，但是由于stop方法是不安全的，不鼓励使用，可以通过run方法里的条件变通实现线程的stop。

4、Executor
    Executor执行器管理Thread对象，从而简化并发编程。

    ExecutorService(具有服务生命周期的Executor)知道如何构建恰当的上下文来执行Runnable对象。

    CachedThreadPool中使用shutdown():
    当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。
    此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。
    但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。

5、常见线程池
    (1)FixedThreadPool:正规线程池。
       可以一次性执行代价高昂的线程分配，因而也就可以限制线程的数量了。
       可以节省时间，不需要为每个任务都付出创建线程的开销。
       (这是一个有指定线程数的线程池，有核心线程，有固定的线程数量，响应速度快，多用于服务器。
       核心线程没有超时机制，队列大小没有限制，除非线程池关闭了，核心线程才会被回收。)

    (2)CachedThreadPool:缓存线程池。
       在程序执行时，通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。
       只有当这种方法会引发问题时才会选择FixedThreadPool。
       (只有非核心线程，有超时机制，当空闲的线程超时未用就会被回收。缺点:没有考虑到系统的实际内存大小。)

    (3)SingleThreadExecutor:单线程池，只有一个核心线程。
       如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，
       每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。
       SingleThreadExecutor会序列化所有提交给它的任务，并会维护自己隐藏的悬挂任务队列。
       (按先入先出的顺序执行任务。不处理并发的操作，不会被回收，效率慢。)

    (4)ScheduleThreadPool:


    FixedThreadPool如果用了Thread.sleep(),会抛出异常
    =====java.lang.InterruptedException: sleep interrupted,所以不可用Thread.sleep()来打断线程


6、System.currentTimeMillis():获取系统当前时间

7、Thread.currentThread().getId():
    Thread.currentThread()是Thread的一个静态方法，用来获取当前线程对象的一个引用。
    Thread.currentThread().getName():当前线程名字;
    Thread.currentThread().getPriority():当前线程的优先级别;
    Thread.currentThread().getId():当前线程的优先级别;

